# Thomas Cornelius
# Shyam Patel
# CMSC417 Project 3
# Part 1 submission

#!!! Test marker

require 'socket'
require "/home/core/graph"

# --- global variables
$port = 9998
$ttl = 0
$packet_size = 256
$costs_path = "/home/core/costs.csv"
$dump_path = "table.dump"
$dump_interval = 10
$round_delay = 5
$costs_delay = 60
$round_time = Time.now
$costs_time = Time.now
$dump_time = Time.now
$version = 0
$me_node = nil

$circuits = []

#used to map ip addresses to hostnames
$my_hostname = ""
$hostnames = {}
$my_interfaces = [] #array of this host's interfaces

$my_links = {}      #hashmap of neighbor hostnames to interfaces: e.g. for n1: 
                    #my_links["n2"] = "10.0.1.21"
                    #keyset is list of neighbor hostnames

$costs = {}         #hashmap of neighbor hostnames to their costs. updated
                    #periodically by update_costs()

$routing_table = {} #hashmap of destinations to next nodes

$received_broadcasts = [] #array of received advertisements

$network = nil

class Circuit
    attr_accessor   :tag,:next_node
    
    def initialize(tag,next_node)
        @tag = tag
        @next_node = next_node
    end
end

#initializes global vars from config file, initializes network graph,
#propagates hashmap of ip addresses to hostnames, identifies self
#creates graphnode of self and inserts into graph.
def init()
	#puts "initializing global variables"
	lines = IO.readlines("/home/core/global.cfg")
	lines.each{ |l|
		elements = l.split("=") #splitting by =
		if elements[0] == "packet_size"
			$packet_size = elements[1].to_i
		end
		
		if elements[0] == "costs_path"
			$costs_path = elements[1]
		end

		if elements[0] == "update_interval"
			$round_delay = elements[1].to_i
		end

		if elements[0] == "dump_path"
			$dump_path = elements[1]
		end

		if elements[0] == "dump_interval"
			$dump_interval = elements[1].to_i
		end
	}
	
    #identify self
    $my_hostname = `hostname`   #executes unix command 'hostname'
    $my_hostname = $my_hostname.strip()
    #!!!
    #$my_hostname = "n1"         #test case
    #puts $my_hostname

    #---propagating ip to hostname hashmap
    lines = IO.readlines("/home/core/nodes-to-addrs.txt")
    lines.each{ |l|
        elements = l.split(" ")
        #puts elements[0],elements[1]
        $hostnames[elements[1]] = elements[0] # "'10.0.0.20' = 'n1'"
        
        
        if elements[0] === $my_hostname
            #puts "adding"
            $my_interfaces.push(elements[1]) #keep track of our interfaces
        end
    }
  
    #puts $my_interfaces
    #figure out neighbors + their interfaces. store key val pairs in $my_links

    lines = IO.readlines("/home/core/addrs-to-links.txt")
    lines.each{ |l|
        elements = l.split(" ")
        
        if $my_interfaces.include? elements[0]
            $my_links[$hostnames[elements[1]]] = elements[1]
        end

        if $my_interfaces.include? elements[1]
            $my_links[$hostnames[elements[0]]] = elements[0]
        end
    }

    #puts $my_links.keys
    
    # populating $costs
    

	#---initialize graph
	$network = Graph.new()
	#---insert self into graph
    
	me = Graph_Node.new($my_hostname,$version)
    $me_node = me
    
    #puts $my_links.keys
    $my_links.keys.each{ |host|
        #puts "adding neighbor to graph"
        node = Graph_Node.new(host, $version)
        temp = {}
        $network.add_node(node, temp)
    }
    
    $network.add_node(me, $costs)
    
   
    cost_lines = IO.readlines("/home/core/costs.csv")
    
    #!!!
    #lines = IO.readlines("costs.csv")   #for testing purposes
    
    #neighbors_mentioned = []
    #---
    
	cost_lines.each{ |l|
		elements = l.split(",")	#splitting by commas
        temp_node = nil
		if $my_interfaces.include? elements[0] #if entry is relevant to us
			#puts $costs.inspect
            
            neighbor = $hostnames[elements[1]]
            #puts neighbor.class

            $network.vertices.keys.each{ |v|
                if v.hostname === neighbor
                    temp_node = v
                end
            }
            
            cost = elements[2].to_i
            #puts "keys "+"#{$costs.keys}"

            if not(neighbor.class == String)
                next
            end

            #puts neighbor
            
			$costs[neighbor] = cost
            #puts $costs.inspect
            #puts temp_node
            $network.vertices.keys.each{ |k|
                #puts "#{k.hostname}: #{$network.vertices[k].inspect}"
            }
            if not(temp_node == nil)
                $network.vertices[me][temp_node] = cost
                $network.vertices[temp_node][me] = cost
            end
            #puts
                       
            #add other way?
            #puts $costs.inspect
            #neighbors_mentioned.push(neighbor)
            #puts i
            
		end

	}
    
    $network.vertices.keys.each{ |k|
        $network.vertices[k].keys.each{ |k2|
            if k2.class == String
                $network.vertices[k].delete(k2)
            end
        }
    }
    #---
	$network.vertices.keys.each{ |k|
        #puts "#{k.hostname}: #{$network.vertices[k].inspect}"
    } 

    #puts $network.vertices.keys
    #exit()
    #---run djikstras, generate early routing table

end

#runs periodically. updates direct neighbor costs by reading in costs file.
def update_costs()
	#puts "updating costs from file"
	lines = IO.readlines("/home/core/costs.csv")
    #!!!
    #lines = IO.readlines("costs.csv")   #for testing purposes

    #neighbors_mentioned = []

	lines.each{ |l|
        #puts l
		elements = l.split(",")	#splitting by commas

		if $my_interfaces.include? elements[0] #if entry is relevant to us
			temp_node = nil
            neighbor = $hostnames[elements[1]]

            #puts $network.vertices.keys.inspect
            $network.vertices.keys.each{ |v|
                if v.hostname === neighbor
                    temp_node = v
                end
            }

            cost = elements[2].to_i
			$costs[neighbor] = cost

            if $network.vertices[temp_node] == nil
                $network.vertices[temp_node] = {}    
            end
            
            if not(temp_node == nil)
                $network.vertices[$me_node][temp_node] = cost
                $network.vertices[temp_node][$me_node] = cost
            end
            #neighbors_mentioned.push(neighbor)
		end

	}

    #neighbors_mentioned.each{ |n|
     #   if not($my_links.keys.include? n)
            #add to everything
      #  end

    #}

    #$my_links.keys.each{ |n|
     #   if not(neighbors_mentioned.include? n)
            #remove from everything
      #      $my_links
       # end

    #}



    #puts $costs.inspect
    #---update graph with new information
    
end

#runs periodically - updates routing table
def update_routing_table(graph, me)
    #puts "Updating routing table"
    # run dijsktra from us to every other node in the graph $network
    
    $routing_table[$my_hostname] = $my_hostname
    graph.vertices.keys.each {|host|
        #puts "#{host.hostname}: #{graph.vertices[host].inspect}"
        #puts
        if(host.hostname != $my_hostname)
            
            # running dijkstra's on every node in the graph from the current node and adding the 1st neighbor to the routing table.

            
            next_neighbor = graph.dijkstra(me, host)
            if(next_neighbor.class == Array)
                $routing_table[host.hostname] = next_neighbor.last
            else
                $routing_table[host.hostname] = -1
            end
        end
    }


end

#runs periodically. floods network with advertisement packets.
def broadcast()
	#puts "broadcasting packets"
	#construct advertisement packet message
    #puts "#{$costs.inspect}"
    hash = {}
    $costs.keys.each{ |k|
        if k.class == String
            hash[k] = $costs[k] #weed out mystical spooky keys
        end
    }
	message = "FLOOD#{$my_hostname},#{hash.inspect},#{$version}"
    #puts message
    #broadcast message to all neighbors
    #puts "hi "+"#{$my_links}"
    $my_links.keys.each{ |host|
        
        begin
            #puts "sending packet to #{host}: #{$my_links[host]}"
            sock = TCPSocket.new($my_links[host], $port)    #open socket
            sock.write(message)                             #sending message
            sock.close
        rescue Errno::ECONNREFUSED
            #puts "connection refused"
        end
    }

end

#function to handle external advertisement packets
def flood(message)
	#puts "processing advertisement packet"
    if($received_broadcasts.include?(message))
        return
    end

    $received_broadcasts.push(message)

    packet = message.split(",")
    sender = packet[0]

    #receive a packet. forward it to all neighbors except sender.
    #ignore packets from self
    #process message.
    /FLOOD(.*),\{(.*)\},(.*)/.match(message)
    sender = $1
    #puts sender
    if sender === $my_hostname
        return
    end

    links = $2
    version = $3

    links = links.strip
    
    link_list = links.split(', ')
    
    link_list.each{ |link|
        elements = link.split("=>")
        neighbor = elements[0][1..elements[0].length-2] #strip quotes
        
        cost = elements[1].to_i
        node = nil
        node2 = nil

        $network.vertices.keys.each{ |v|
            if v.hostname === neighbor
                node = v
            end
        }

        if node == nil
            #if neighbor is not known
            node = Graph_Node.new(neighbor,$version)
            $network.add_node(node, {})
        end

        #make sure this doesn't have quotes around it
        $network.vertices.keys.each{ |v|
            if v.hostname === sender
                node2 = v
            end
        }

        if node2 == nil
            node2 = Graph_Node.new(sender,$version)
            $network.add_node(node2, {})
        end
        #puts node2
        #puts $network.vertices[node2]
        if $network.vertices[node] == nil
            $network.vertices[node] = {}    
        end

        if $network.vertices[node2] == nil
            $network.vertices[node2] = {}    
        end

        if (not(node2 == nil) and not(node == nil))
            $network.vertices[node2][node] = cost
            $network.vertices[node][node2] = cost
        end
    }

    $my_links.keys.each{ |host|
        
        if not(host == sender)    
            begin
                sock = TCPSocket.new($my_links[host], $port)    #open socket
                sock.write(message)                             #sending message
                sock.close
            rescue Errno::ECONNREFUSED
            end
        end

    }
    
    
    
	update_routing_table($network, $me_node)
end


#runs periodically. dumps routing table to file for grading purposes.
def dump_table()
    #puts "======= Routing Table ======="
	#puts $routing_table.inspect
    File.open($dump_path, 'w'){ |file|

        file.write("====Routing Table:#{$my_hostname}====\n")
        file.write("DEST\t\tNEXT\n")
        $routing_table.keys.each{ |k|
            moop = $routing_table[k]
            
            if not($routing_table[k].class == String)
                moop = $routing_table[k].hostname
            end

            file.write("#{k}\t\t#{moop}\n")
        }
    }
    sleep(1)
    #will complete after routing table functionality is implemented
end

#establishes a virtual circuit along the path to hostname
def establish_circuit(hostname)
    node = $routing_table[hostname]
    if node == nil
        puts "unable to route to host"
        return
    end

    nextnode = $routing_table[node]
    message = "CIRCUIT#{$my_hostname}->#{node.hostname}"
    
    #---propagate fields of struct & add to list
    c = Circuit.new("#{$my_hostname}->#{hostname}", node)
    $circuits.push(c)

    #--- 

    begin
        #puts "sending packet to #{host}: #{$my_links[host]}"
        sock = TCPSocket.new($my_links[hostname], $port)    #open socket
        sock.write(message)                             #sending message
        sock.close
    rescue Errno::ECONNREFUSED
        puts "connection refused"
    end
    
end

def handle_circuit(message)
    #puts("establishing circuit on this node")
    /CIRCUIT(.*)->(.*)/.match(message)
    src = $1
    dst = $2

    if dst === $my_hostname
        c = Circuit.new("#{$1}->#{$2}", nil)
        $circuits.push(c)
        return  
    end

    node = $routing_table[dst]
    

    #---propagate fields of struct & add to list
    c = Circuit.new("#{$1}->#{$2}", node)

    #---    
    begin
        #puts "sending packet to #{host}: #{$my_links[host]}"
        sock = TCPSocket.new($my_links[node.hostname], $port)    #open socket
        sock.write(message)                             #sending message
        sock.close
    rescue Errno::ECONNREFUSED
        #puts "connection refused"
    end
    
end

def handle_sendmsg(cmd)
    return
end

def start_ping(cmd, ping_socket)
    puts "pinging..."

    /PING (.+) (.+) (.+)/.match(cmd)
    dst = $1
    numpings = $2
    delay = $3

    if(not($routing_table.keys.include? dst))
        puts "Hostname not found."
        return
    end

    #craft ping message
    message = "PING #{$my_hostname}->#{$1}"
    nextnode = $routing_table[dst].hostname
    
    num = numpings.to_i
    #send it forward
    begin
        while(num > 0)
            start_time = Time.now
            puts "pinging #{nextnode}:"
            sock = TCPSocket.new($my_links[nextnode], $port-1)
            sock.write(message)
            sock.close
            
            #handle ping messages until complete or timeout
            
            loop{
                begin
                    conn = ping_socket.accept_nonblock
                    mess = conn.recv($packet_size)
                    #puts "mess=#{mess}"
                    conn.close()
                    ret = handle_ping(mess)
                    if ret == "done"
                        end_time = Time.now
                        puts "Reply from #{dst}: time=#{end_time-start_time}s"
                        break
                    end

                    if (Time.now - start_time > 5)
                        puts "ERROR: ping timeout"
                        break
                    end

                rescue Errno::EAGAIN,Errno::EWOULDBLOCK
                #nothing in queue!
                end
            }

            num = num - 1
            sleep(delay.to_i)
        end
    rescue Errno::ECONNREFUSED
        puts "connection refused"
    end
end

def handle_ping(message)
    #puts "received ping msg: #{message}"
    /(.*) (.*)->(.*)/.match(message)
    ping = $1
    src = $2
    dst = $3

    if(not($routing_table.keys.include? dst))
        puts "Hostname not found."
        return
    end

    if(dst == $my_hostname and ping == "PING")
        #send PINGResponse packet back
        retmess = "PINGR #{$3}->#{$2}"
        nextnode = $routing_table[$2]
        begin
            sock = TCPSocket.new($my_links[nextnode], $port-1)
            sock.write(retmess)
            sock.close
        rescue Errno::ECONNREFUSED
            puts "connection refused"
        end
        
        return

    elsif (dst == $my_hostname and ping == "PINGR")
        return "done"
    end

    #craft ping message
    mess = "#{$1} #{$2}->#{$3}"
    nextnode = $routing_table[dst].hostname
    
    #send it forward
    begin
        sock = TCPSocket.new($my_links[nextnode], $port-1)
        sock.write(mess)
        sock.close

    rescue Errno::ECONNREFUSED
        puts "connection refused"
    end
end

def handle_traceroute(cmd)
    return
end
# --- perform initialization tasks ---

#-> call update_costs() for the first time, propagate neighbor array
#-> identify hostname of self

init()

update_costs()
update_routing_table($network, $me_node)
#dump_table()
#exit()

serv_socket = TCPServer.new('',$port)
serv_socket.listen(15)   #backlog of 15

ping_socket = TCPServer.new('',$port-1)
ping_socket.listen(15)  #backlog of 15

#!!!
sleep(3)       #make sure all other nodes are listening?

broadcast()     #first broadcast

while 1 < 2 do	#infinite server loop

	curr_time = Time.now

	#check if time to update neighbor costs
	if curr_time - $costs_time >= $costs_delay
		update_costs()
		$costs_time = curr_time
	end

	#check if time to broadcast packets
	if curr_time - $round_time >= $round_delay
		broadcast()
		$round_time = curr_time
	end

    #check if time to dump routing table
    if curr_time - $dump_time >= $dump_interval
        dump_table()
        $dump_time = curr_time
    end


    #---handle received messages---
    begin
        conn = serv_socket.accept_nonblock  #accept a connection if any in queue
        message = conn.recv($packet_size)
        #puts message
        conn.close()
        
        #if it's an advertisement
        
        if message[0..4] == "FLOOD"
            flood(message)
        end

        if message[0..6] == "CIRCUIT"
            handle_circuit(message)        
        end
    

    rescue Errno::EAGAIN,Errno::EWOULDBLOCK
        #nothing in queue!
    end

    #---handle received pings---
    begin
        conn = ping_socket.accept_nonblock  #accept a connection if any in queue
        message = conn.recv($packet_size)
        #puts message
        conn.close()
        
        #if it's an advertisement
        
        if message[0..3] == "PING"
            handle_ping(message)
        end
    

    rescue Errno::EAGAIN,Errno::EWOULDBLOCK
        #nothing in queue!
    end

	#--- check for user input (i.e. message sending) ---
    
    begin

        cmd = $stdin.read_nonblock(80) #max command size = 80 chars
        #puts "cmd=#{cmd}"    
        #process command
        if(cmd[0..6] == "SENDMSG")
            #handle SENDMSG
            start_sendmsg(cmd)
        elsif (cmd[0..3] == "PING")
            #handle PING
            start_ping(cmd, ping_socket)
        elsif(cmd[0..9] == "TRACEROUTE")
            #handle TRACEROUTE
            start_traceroute(cmd)
        else
            puts "Invalid command."
        end

    rescue Errno::EWOULDBLOCK, Errno::EAGAIN
        #if no input
    end
end
